
package djinni;

import djinni.ast.Record.DerivingType
import djinni.ast._
import djinni.generatorTools._
import djinni.meta._
import djinni.writer.IndentWriter

import scala.collection.mutable

/**
  * Created by abrenner on 6/28/2016.
  */
class MIDLGenerator(spec: Spec) extends Generator(spec) {

  var marshal = new MIDLMarshal(spec)

  class MidlRefs() {
    var idl = mutable.TreeSet[String]()
  }

  def writeMIDLFile(ident: String, origin: String, refs: Iterable[String], f: IndentWriter => Unit) {
    createFile(spec.midlOutFolder.get, idMidl.ty(ident) + ".idl", (w: IndentWriter) => {
      w.wl("// AUTOGENERATED FILE - DO NOT MODIFY!")
      w.wl("// This file generated by Djinni from " + origin)
      w.wl
      if (refs.nonEmpty) {
        refs.foreach(s => w.wl(s"""import "$s";"""))
        w.wl
      }
      w.wl(s"#define COMPONENT_VERSION 1.0")
      spec.midlPackage.foreach(s => w.wl(s"namespace $s").braced {
        f(w)
      })
    })
  }

  override def generateEnum(origin: String, ident: Ident, doc: Doc, e: Enum) {
    var refs = new MidlRefs();
    refs.idl.add("inspectable.idl");
    refs.idl.add("Windows.Foundation.idl");

    writeMIDLFile(ident, origin, refs.idl, w => {
      writeDoc(w, doc)
      w.w(s"typedef enum {")
      for (o <- e.options) {
        writeDoc(w, o.doc)

        if (o != e.options.last) {
          w.w(idMidl.enum(o.ident) + ",")
        } else {
          w.w(idMidl.enum(o.ident))
        }
      }
      w.w(s"} ${marshal.typename(ident, e)};")
      w.wl
    })
  }

  override def generateInterface(origin: String, ident: Ident, doc: Doc, typeParams: Seq[TypeParam], i: Interface) {

  }

  override def generateRecord(origin: String, ident: Ident, doc: Doc, params: Seq[TypeParam], r: Record) {

  }

}
